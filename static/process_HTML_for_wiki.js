onmessage = function(event) 
{
    // This method assumes that double bracket *always* indicates a wiki node path regardless of
    // it's location in the source
    // I presume there is some way to use jquery from a web worker. Once I figure that out I think
    // this algo would be better: Parse the HTML fragment data and then use jquery to only scan the
    // wiki links that are not in code tags.
    //
    // for now we avoid just the HTML generated by ``[[wiki_word]]``. Every other instance of
    // [[wiki_word]] is assumed to be replacable by the a link
    var src = new String(event.data);

    var start_match = /[^>]\[\[/gm;

    var node_path_match = /(\w+(?:\/\w+)*)\]\]/g;

    var parse_state = 'pre_start';

    var pending = null;

    var step_parser = function()
    {
        switch( parse_state )
        {
            case 'pre_start':
                var m = start_match.exec( src );

                if( null == m && null != pending )
                    pending.is_final = true;

                if( null != pending )
                    postMessage( pending );

                pending = null;

                if( null == m )
                    return;

                node_path_match.lastIndex = start_match.lastIndex;

                parse_state = 'in_brackets';
                break;
            case 'in_brackets':
                var m = node_path_match.exec( src );

                if(null == m)
                {
                    parse_state = 'pre_start';
                    break;
                }

                pending = { node_path: m[1] 
                          , start_index: start_match.lastIndex
                          , end_index: node_path_match.lastIndex - 2
                          , is_final: false
                          };

                start_match.lastIndex = node_path_match.lastIndex;

                parse_state = 'pre_start';
                break;
        }

        setTimeout( step_parser, 50 );
    };
    
    setTimeout( step_parser, 50 );
};

